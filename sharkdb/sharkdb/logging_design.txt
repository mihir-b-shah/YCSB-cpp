
Just a side note, make sure we don't hold namespace locks for too long- should be fine, what we are
doing now, where we hold them during a R/W op?

Problems with the current design:
- We fsync on every operation. We can change this to fsync on every write batch submitted (Commit 61118d). This is a baseline to measure logging perf (throughput, vs latency)
- The MAIN benefit of RocksDB's logging scheme is READ performance- i.e. that readers do not block
  writers. This "sounds" like MVCC in a sequentially consistent system- but it's not- two writes to the
  same key can be logged together. Note we still get reasonable semantics- if I write a value myself,
  it will be persisted and then return to me- so a future read I do WILL read that value.
- As such, we want to measure read perf. We should do this on a highly skewed dataset- so that it
  maximally stresses the reads on a small (and cacheable) set- so I can essentially ignore compaction,
  to make my life simple. 

It is obvious my system will get very poor R performance on a skewed dataset. Consider every op is on the
same key. Then on every write in the current system, we will block readers. Suppose we have workload A
from ycsb- this means for each log op, while we hold the lock, no reads will proceed.

-------------
To implement
-------------

Write path:
- write to log buffer
	- no need for a separate logging thread. Just have a method, that the foreground threads run. The 
	  critical thing is for it to be O(1).
	- the l0 object should maintain a log buffer.
	- how to manage the log buffer? we append to it to mirror what we will write to the WAL. However,
	  for a heavy contention workload, just like the log-structured FS, lots of stuff will get
	  overwritten, as such we will make poor use of the log_buffer. This allows using overwritten slots
	  as extra cache space.
- update memtable's mvcc data structure that points to the log buffer
	- how should this be maintained? maintain an epoch number (rather than a full timestamp).
	  for any key, I need to maintain two things- a pointer to the last committed state, and to
	  the last un-committed state.
	- suppose a read comes in. At that point, it should use the "last committed state" pointer. Once
	  there, it has a pointer directly to the log buffer, which is live until mem-table flush- regardless
	  of future writes that come in.
	- suppose a write comes in. If there is a current un-committed write, just replace it, nobody can
	  read it anyway. 
- push completion event into the private queue
	- maintain a private queue where we write completions.

Read path
- sync for now

